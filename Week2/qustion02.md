# map和slice扩容的区别 #
## 1. Slice 扩容
 **原理**：在 Go 中，slice 的底层是一个动态数组。当 slice 的容量不足时，需要进行扩容操作。扩容的实现方式是在内存中分配一个新的、容量更大的数组，然后将旧数组的内容拷贝到新数组中。  
 
*  **增长策略**：
对于小规模的 slice，扩容时会将容量翻倍。  
对于较大的 slice（容量达到 1024 以上），扩容会按 1.25 倍的因子增长。  
* **重新分配内存**：扩容后，旧的底层数组会被垃圾回收，因为不再使用它。  
* **性能影响**：由于需要将旧数据拷贝到新的数组中，扩容可能会带来性能开销，尤其在大规模数据或频繁扩容的情况下。
```Go
s := []int{1, 2, 3}
s = append(s, 4) // 如果容量不够，则进行扩容，创建新数组并拷贝数据
```
## 2. Map 扩容 ##
* **原理**：Go 中的 map 是基于哈希表实现的，存储数据时会根据哈希值将数据分配到不同的桶（bucket）中。当桶中的元素数超过一定阈值时，map 会自动进行扩容。  
* **增长策略**：  
>map 的扩容并非简单地将容量翻倍，而是基于桶的数量（2 的幂）来调整大小。
>扩容后，哈希表的桶会重新分配，并将已有元素重新散列到新的桶中。

* **渐进式扩容**：与 slice 的一次性扩容不同，map 的扩容是渐进式的，不会一次性将所有数据都搬迁。只有在后续添加或删除元素时，旧桶的数据才会逐步迁移到新桶。  
* **性能影响**：由于渐进式扩容，map 扩容对性能的瞬时影响较小，可以避免某一时刻的高开销。但在大量数据插入的过程中，可能会有一定的性能损耗。
```Go
m := make(map[int]int)
for i := 0; i < 100; i++ {
    m[i] = i // 在插入过程中，map 会自动扩容
}
```
|特性|	Slice|	Map|
|----|------|------|
|底层结构	|动态数组|	哈希表|
|扩容触发条件	|append |导致容量不足时	|桶内元素超过阈值|
|增长策略	|小规模翻倍，大规模 1.25 倍|	桶数量按 2 的幂次增长|
|扩容方式	|一次性分配新数组并拷贝旧数据|	渐进式扩容，逐步迁移数据|
|性能影响	|大量拷贝可能影响性能	|渐进扩容，瞬时影响较小|
